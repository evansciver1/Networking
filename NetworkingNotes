----------------------------------------------------------------------------------------------------------------------------------------------------------
Day 1
----------------------------------------------------------------------------------------------------------------------------------------------------------
- 'eog [file]' will open an image from linux to your screen
  - Network Fundamentals:
    - Byte = 8 bits
    - Half Word = 16 bits
    - Word = 32 bits
    - Base 2 = binary
    - Base 10 = normal numbers
    - Base 16 = hex
    - Base 64 = binary to ascii conversion
    - Message Formatting Encapsulation and Decapsulation - https://git.cybbh.space/net/public/raw/master/modules/networking/slides/images/PDU_SDU.png
    - OSI Model Diagram - https://git.cybbh.space/net/public/raw/master/modules/networking/slides/images/OSI.png
    - IETF.org/standards - has technical memos on everything dealing with every 802.11 ammendment
      - Physical Layer/OSI Layer 1:
        -hardware specs, encoding and signaling, data transmission and reception, physical network design
      - Data Link Layer/OSI Layer 2:
        - Switching happens here; Ethernet, ARP, and 802.1Q headers
        - Sub Layers - MAC (Media Access Control), LLC (Logical Link Control)
      - Network Layer/OSI Layer 3:
        - Fragmentation Process - https://git.cybbh.space/net/public/raw/master/modules/networking/slides/images/Fragmentation.png
        - Fragmentation bits - RES (reserved - evil bit, always 0), DF (don't fragment - off if a packet is fragmented),
          MF (more to follow - on if fragmented unless it's the last packet of a fragment), 
          Offset (helps recieving machine to arrange packets in order when they arrive)
        - Calculating Fragmentation Offset - Formula: (MTU - (IHL x 4)) / 8 = offset
        - Fingerprinting - devices can be identified based on TTL and TCP Window Size; but these are not definitive
          - https://git.cybbh.space/net/public/raw/master/modules/networking/slides/images/Default_TTL.png
        - Zero Configuration
          - IPv4 Auto-Configuration used APIPA and RFC 3927
          - IPv6 uses SLAAC and RFC 4862
----------------------------------------------------------------------------------------------------------------------------------------------------------
Day 2
----------------------------------------------------------------------------------------------------------------------------------------------------------
  - Network Fundamentals (cont.):
    - Transport Layer/OSI Layer 4:
      - TCP and UDP 
    - Session Layer/OSI Layer 5:
      - Protocols: Socks, NetBIOS, PPTP/L2TP, RPC
      - SMB/CIFS: SMB rides over NetBIOS; SAMBA and CIFS are just flavors of SMB
      - RPC: any port, request/response protocol
    - Presentation Layer/OSI Layer 6:
      - Responsible for translation, formating, encoding, encryption, and compression
    - Application Layer/OSI Layer 7:
      - FTP: active and passive mode
        - FTP Active Issues:
          - NAT and Firewall traversal issues
          - Complications with tunneling through SSH
          - Passive FTP solves issues related to active mode is is most often used in modern systems
      - SSH
        - SSH Messages Provide:
          - Client/server authentication
          - Asymmetric or PKI for key exchange
          - Symmetric for session
          - User authentication
          - Data stream channeling
        - SSH Architecture:
          - Server, Client, Session, Keys, Key Generator
            - SSH Keys:
              - User - asymmetric public key used to identify the user to the server
              - Host - asymmetric public key used to identify the server to the user
              - Session - symmetric key created by the client and server to protect the session's communication
      - HTTP(S):
        - Methods are GET/HEAD/POST/PUT
        - Status Codes are 100, 200, 300, 400
  - Network Traffic Sniffing:
    - Capture Library:
      - Traffic Capture is possible because of Libpcap, WinPcap, NPCAP
    - TCPDump Demo:
      - sudo tcpdump [filter] 
      - -I specifies an interface
      - -D shows interfaces
      - -r reads from a file
      - -X shows hex and ascii
      - -XX adds additional header info
      - -v adds verbosity
      - -w writes to a file
      - filters are generally in normal language i.e. sudo tcpdump 'tcp port 80' -r [file] only shows packets on port 80
      - -n changes protocol names to port numbers
  - Berkeley Packet Filters (BPF):
    - Requests a SOCK_RAW socket and setsockopt calls SO_ATTACH_FILTER
    - sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL))
      ...
      setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, ...)
    - Using BPFs with operators, bitmasking, and TCPDump creates a powerful tool for traffic filtering and parsing
    -  tcpdump {A} [B:C] {D} {E} {F} {G}
      - A = Protocol (ether | arp | ip | ip6 | icmp | tcp | udp)
      - B = Header Byte offset
      - C = optional: Byte Length. Can be 1, 2 or 4 (default 1)
      - D = optional: Bitwise mask (&)
      - E = Operator (= | == | > | < | <= | >= | != | () | << | >>)
      - F = Result of Expresion
      - G = optional: Logical Operator (&& ||) to bridge expressions
      - Example: tcpdump 'ether[12:2] = 0x0800 && (tcp[2:2] != 22 &&
    - Bitwise Masking - https://git.cybbh.space/net/public/raw/master/modules/networking/slides/images/ver-ihl-bpf.png:
      - Filter down to bits an not just the byte; ex: ip[0] & 0x0F > 0x05 = looks at the PSH  RST SYN AND FIN bits to see if they're total greater than 5
      - Most Exclusive - All designated bit values must be set; no others can be set (tcp[13] = 0x11 or tcp[13] & 0xFF = 0x11)
      - Less Exclusive - All designated bits must be set; all others may be set (tcp[13] & 0x11 = 0x11 - ack and fin have to be on; all others can be whatever)
      - Least Exclusive - At least one of the designated bits must be set to not equal 0; all others may be set (tcp[13] & 0x11 !=0)
  - Layer 2 Switching Technologies: 
    - VLANS and IEEE 802.1Q - https://git.cybbh.space/net/public/raw/master/modules/networking/slides/images/802.1QFrame.png
    - IEEE 802.1AD "Q-in-Q" - https://git.cybbh.space/net/public/raw/master/modules/networking/slides/images/802.1adFrame.jpg and 
      https://git.cybbh.space/net/public/raw/master/modules/networking/slides/images/doubletags.png
  - Layer 3 Switching Technologies
    - Routing Tables - yeah
----------------------------------------------------------------------------------------------------------------------------------------------------------    
Day 3
----------------------------------------------------------------------------------------------------------------------------------------------------------
  - Packet Creation and Socket Programming:
    - Socket Types:
      - Stream Sockets - Connection oriented and sequenced; methods for connection establishment and tear-down. Used with TCP, SCTP, and Bluetooth
      - Datagram Sockets - Connectionless; designed for quickly sending and receiving data. Used with UDP.
      - Raw Sockets - Direct sending and receiving of IP packets without automatic protocol-specific formatting.
    - User vs. Kernel Space Sockets:
      - User Space:
        - Stream, Datagram
      - Kernel:
        - Raw
    - Socket Creation and Privilege Level:
      - User Space Sockets: the most common sockets that do not require elevated privileges to perform actions on behalf of user applications.
      - Kernel Space Sockets: Attempts to access hardware directly on behalf of a user application to either prevent encapsulation/decapsulation 
        or to create packets from scratch, which requires elevated privileges.
    - Network Programming with Python3:
      - Network sockets primarily use the Python3 socket and socket.socket function
      - import socket
  s = socket.socket(socket.FAMILY, socket.TYPE, socket.PROTOCOL)

The socket.socket Function

    Inside the socket.socket. function, you have these arguments, in order:

socket.socket([*family*[,*type*[*proto*]]])

    family constants should be: AF_INET (default), AF_INET6, AF_UNIX

    type constants should be: SOCK_STREAM (default), SOCK_DGRAM, SOCK_RAW

    proto constants should be: 0 (default), IPPROTO_RAW

Python3 Libraries and References

Socket
	

https://docs.python.org/3/library/socket.html

Struct
	

https://docs.python.org/3/library/struct.html

Sys
	

https://docs.python.org/3/library/sys.html
Python3 Libraries and References (Cont)

Errors
	

https://docs.python.org/3/tutorial/errors.html

Exceptions
	

https://docs.python.org/3/library/exceptions.html
Stream and Datagram Socket Demos

Follow along with the instructor on the Internet Host
7.1
Network Programming with Python3Network sockets primarily use the Python3 Socket library and socket.socket function.import socket s = socket.socket(socket.FAMILY, socket.TYPE, socket.PROTOCOL)

